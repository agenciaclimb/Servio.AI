diff --git a/DOCUMENTO_MESTRE_SERVIO_AI.md b/DOCUMENTO_MESTRE_SERVIO_AI.md
index 8027ec7..073f57e 100644
--- a/DOCUMENTO_MESTRE_SERVIO_AI.md
+++ b/DOCUMENTO_MESTRE_SERVIO_AI.md
@@ -4438,3 +4438,55 @@ GET  /api/whatsapp/multi-role/templates/:userType
 
 _√öltima atualiza√ß√£o: Integra√ß√£o de matching de IA no dashboard do cliente implementada e validada_  
 _Pr√≥xima revis√£o: Task 2.5 | Advanced Matching Features_
+
+# ========================================
+
+# ATUALIZA√á√ÉO AUTOM√ÅTICA ‚Äî 2025-12-11T14:25:32.0110283-03:00
+
+=== ATUALIZA√á√ÉO DO DOCUMENTO MESTRE ‚Äî PR #26 ===
+
+**Data**: 11/12/2025 16:15 BRT  
+**Respons√°vel**: Gemini (Auditoria Aprovada - Protocolo Supremo v4.0)
+
+**PR #26: Protocolo Supremo v4.0 (Isolado e Audit√°vel)**
+
+**Resumo T√©cnico**: O Protocolo Supremo v4.0 foi apresentado para auditoria e aprovado pelo Gemini. Este protocolo unifica e redefine os processos de desenvolvimento e implementa√ß√£o, com foco em responsabilidades claras, ciclo de vida imut√°vel e rastreabilidade completa.
+
+**Veredito**: ‚úÖ **APROVADO - Sem ressalvas**
+
+**Impactos na Arquitetura**:
+
+- **Hierarquia Oficial**: Gemini (Auditor Global), Copilot (Executor T√©cnico), Orchestrator (Motor de Tasks)
+- **Princ√≠pio Supremo**: Documento Mestre √© a fonte √∫nica de verdade
+- **Ordem do Ciclo**: Ciclo imut√°vel de 10 passos para rastreabilidade total
+- **Protocolos**: Auditoria (Gemini) e Execu√ß√£o (Copilot) formalmente definidos
+
+**Principais Mudan√ßas**:
+
+- **Se√ß√£o 2 (Hierarquia)**: Define poderes e proibi√ß√µes de cada agente
+- **Se√ß√£o 3 (Ciclo)**: 10 passos obrigat√≥rios e imut√°veis
+- **Se√ß√£o 4 (Regra de Branches)**: Estrutura clara de controle de vers√£o
+- **Se√ß√£o 6 (Protocolo de Auditoria)**: Procedimento rigoroso do Gemini
+- **Se√ß√£o 7 (Protocolo de Execu√ß√£o)**: Procedimento do Copilot
+
+**Decis√µes Arquiteturais**:
+
+- O Protocolo v4.0 define o novo padr√£o operacional do ecossistema Servio.AI
+- Implementa√ß√£o ser√° incremental atrav√©s de tasks geradas pelo Gemini
+- Cada mudan√ßa ser√° auditada conforme protocolo antes de merge
+- Zero toler√¢ncia a viola√ß√µes do Protocolo Supremo
+
+**Garantia de Converg√™ncia com o Documento Mestre**:
+
+Este PR e auditoria garantem total conformidade com as diretrizes do Protocolo Supremo v3.0 durante a transi√ß√£o para v4.0. A aprova√ß√£o autoriza o in√≠cio da fase de implementa√ß√£o incremental.
+
+**Observa√ß√µes**:
+
+- Protocolo v4.0 est√° oficialmente ativado em main (commit ap√≥s merge de PR #26)
+- Toda a documenta√ß√£o est√° integrada no Documento Mestre
+- Hist√≥rico de rejei√ß√£o do PR #25 foi preservado para aprendizado
+- Sistema agora opera sob novo protocolo de forma controlada e rastre√°vel
+
+**Status**: ‚úÖ **APROVADO - Documento Mestre atualizado ‚Äî Fase de implementa√ß√£o iniciada**
+
+---
diff --git a/ai-tasks/day-3/task-3.1.md b/ai-tasks/day-3/task-3.1.md
new file mode 100644
index 0000000..d7f2bbd
--- /dev/null
+++ b/ai-tasks/day-3/task-3.1.md
@@ -0,0 +1,37 @@
+# Task 3.1 ‚Äî Implementar sistema de tasks autom√°tico (ai-tasks/day-X/)
+
+ID: 3.1
+Protocolo: v4.0
+
+Descri√ß√£o:
+Cria√ß√£o de um sistema autom√°tico para leitura e execu√ß√£o de tasks definidas em arquivos JSON.
+
+Crit√©rios de Aceita√ß√£o:
+
+- Sistema l√™ e parseia arquivos JSON de tasks
+- Sistema valida o schema dos arquivos
+- Sistema executa as a√ß√µes descritas
+- Sistema lida com erros apropriadamente
+- Logging b√°sico das a√ß√µes executadas
+
+Arquivos:
+
+- Criar: `ai-tasks/task_manager.ts`, `ai-tasks/task_interface.ts`, `ai-tasks/task_manager.test.ts`
+- Modificar: (nenhum)
+
+Depend√™ncias: (nenhuma)
+Esfor√ßo Estimado: 8h
+
+Plano de Implementa√ß√£o:
+
+1. Definir `Task` interface e schemas b√°sicos
+2. Implementar `TaskManager` com: carregar JSON, validar, executar handlers
+3. Adicionar logging simples usando console + hooks para integrar logger posterior (Task 3.3)
+4. Escrever testes unit√°rios b√°sicos com Vitest
+5. Preparar branch `feature/task-3.1` e PR para auditoria Gemini
+
+Observa√ß√µes:
+
+- Integrar com futura camada de auditoria (Task 3.3)
+- Arquitetura simples, extens√≠vel para a√ß√µes como cria√ß√£o de arquivos, abrir issues, etc.
+- Garantir que n√£o dependa de servi√ßos externos na primeira vers√£o.
diff --git a/ai-tasks/day-3/task-3.2.md b/ai-tasks/day-3/task-3.2.md
new file mode 100644
index 0000000..b6336ce
--- /dev/null
+++ b/ai-tasks/day-3/task-3.2.md
@@ -0,0 +1,31 @@
+# Task 3.2 ‚Äî Integrar Gemini CLI com GitHub Actions
+
+ID: 3.2
+Protocolo: v4.0
+
+Descri√ß√£o:
+Configura√ß√£o de workflow no GitHub Actions para executar Gemini CLI em eventos de push/PR.
+
+Crit√©rios de Aceita√ß√£o:
+
+- Workflow do GitHub Actions configurado
+- CLI executada em eventos de push e pull request
+- Workflow gera relat√≥rios e logs
+- Workflow configur√°vel para diferentes ambientes
+- Status da execu√ß√£o vis√≠vel no GitHub
+
+Arquivos:
+
+- Criar: `.github/workflows/gemini_cli.yml`
+- Modificar: (nenhum)
+
+Depend√™ncias: (nenhuma)
+Esfor√ßo Estimado: 6h
+
+Plano de Implementa√ß√£o:
+
+1. Adicionar workflow YAML com jobs de audit/validate
+2. Configurar secrets para GEMINI_API_KEY
+3. Executar CLI em `pull_request` e `push`
+4. Artefatos: salvar relat√≥rio de auditoria
+5. Validar em branch de teste
diff --git a/ai-tasks/day-3/task-3.3.md b/ai-tasks/day-3/task-3.3.md
new file mode 100644
index 0000000..8db2618
--- /dev/null
+++ b/ai-tasks/day-3/task-3.3.md
@@ -0,0 +1,31 @@
+# Task 3.3 ‚Äî Criar protocolo de logging e auditoria
+
+ID: 3.3
+Protocolo: v4.0
+
+Descri√ß√£o:
+Sistema de logging centralizado para registrar todas as a√ß√µes do Protocolo Supremo v4.0.
+
+Crit√©rios de Aceita√ß√£o:
+
+- Sistema de logging centralizado implementado
+- Logs incluem timestamps e severidade
+- Sistema de auditoria gera relat√≥rios
+- Sistema gera alertas em eventos suspeitos
+- Logs armazenados com seguran√ßa
+
+Arquivos:
+
+- Criar: `utils/logger.ts`, `utils/auditor.ts`, `models/log_entry.ts`, `utils/logger.test.ts`
+- Modificar: (nenhum)
+
+Depend√™ncias: (nenhuma)
+Esfor√ßo Estimado: 8h
+
+Plano de Implementa√ß√£o:
+
+1. Definir `LogEntry` e n√≠veis (info, warn, error)
+2. Implementar `logger.ts` com rotas de sa√≠da (console, arquivo)
+3. Implementar `auditor.ts` para gerar relat√≥rios a partir dos logs
+4. Testes unit√°rios para formatos e thresholds
+5. Preparar integra√ß√£o com Task 3.1/3.6
diff --git a/ai-tasks/day-3/task-3.4.md b/ai-tasks/day-3/task-3.4.md
new file mode 100644
index 0000000..534db31
--- /dev/null
+++ b/ai-tasks/day-3/task-3.4.md
@@ -0,0 +1,30 @@
+# Task 3.4 ‚Äî Implementar valida√ß√£o de Documento Mestre (parser)
+
+ID: 3.4
+Protocolo: v4.0
+
+Descri√ß√£o:
+Parser para validar a estrutura e conte√∫do do Documento Mestre v4.0.
+
+Crit√©rios de Aceita√ß√£o:
+
+- Parser implementado para validar Documento Mestre v4.0
+- Parser verifica a estrutura do documento
+- Parser verifica campos obrigat√≥rios
+- Parser valida os valores dos campos
+- Testes unit√°rios cobrem cen√°rios de valida√ß√£o
+
+Arquivos:
+
+- Criar: `master_document/parser.ts`, `master_document/schema.json`, `master_document/parser.test.ts`
+- Modificar: (nenhum)
+
+Depend√™ncias: (nenhuma)
+Esfor√ßo Estimado: 10h
+
+Plano de Implementa√ß√£o:
+
+1. Definir `schema.json` com se√ß√µes obrigat√≥rias e tipos
+2. Implementar `parser.ts` para validar contra schema
+3. Testes unit√°rios com casos v√°lidos e inv√°lidos
+4. Integrar parser ao pipeline local (npm script)
diff --git a/ai-tasks/day-3/task-3.5.md b/ai-tasks/day-3/task-3.5.md
new file mode 100644
index 0000000..28a974d
--- /dev/null
+++ b/ai-tasks/day-3/task-3.5.md
@@ -0,0 +1,31 @@
+# Task 3.5 ‚Äî Criar dashboard de status do Protocolo v4.0
+
+ID: 3.5
+Protocolo: v4.0
+
+Descri√ß√£o:
+Dashboard para monitorar status do Protocolo Supremo v4.0 com m√©tricas em tempo real.
+
+Crit√©rios de Aceita√ß√£o:
+
+- Dashboard criado e funcional
+- Exibe vers√£o do protocolo e status das tasks
+- Exibe m√©tricas de erro e tempo de execu√ß√£o
+- Acess√≠vel via web com atualiza√ß√£o em tempo real
+- UI/UX intuitiva
+
+Arquivos:
+
+- Criar: `dashboard/index.html`, `dashboard/app.js`, `dashboard/style.css`, `dashboard/api.ts`
+- Modificar: (nenhum)
+
+Depend√™ncias: (nenhuma)
+Esfor√ßo Estimado: 12h
+
+Plano de Implementa√ß√£o:
+
+1. Estruturar HTML/CSS base
+2. Implementar `app.js` com fetch ao `api.ts`
+3. √çndice de m√©tricas (status por task, erros, tempos)
+4. Atualiza√ß√£o peri√≥dica (polling/websocket futuro)
+5. Validar acessibilidade b√°sica
diff --git a/ai-tasks/day-3/task-3.6.md b/ai-tasks/day-3/task-3.6.md
new file mode 100644
index 0000000..a4f20b8
--- /dev/null
+++ b/ai-tasks/day-3/task-3.6.md
@@ -0,0 +1,30 @@
+# Task 3.6 ‚Äî Testes E2E do ciclo completo (10 passos)
+
+ID: 3.6
+Protocolo: v4.0
+
+Descri√ß√£o:
+Testes End-to-End para validar ciclo completo do Protocolo Supremo v4.0.
+
+Crit√©rios de Aceita√ß√£o:
+
+- Testes E2E implementados para ciclo completo
+- Testes cobrem os 10 passos do protocolo
+- Componentes funcionam corretamente em conjunto
+- Testes geram relat√≥rios detalhados
+- Cobertura de c√≥digo acima de 80%
+
+Arquivos:
+
+- Criar: `e2e/protocol_test.ts`, `e2e/test_data.json`
+- Modificar: (nenhum)
+
+Depend√™ncias: 3.1, 3.2, 3.3, 3.4, 3.5
+Esfor√ßo Estimado: 16h
+
+Plano de Implementa√ß√£o:
+
+1. Escrever cen√°rios cobrindo cada passo do protocolo
+2. Preparar dados de teste em `test_data.json`
+3. Rodar em CI com relat√≥rios
+4. Garantir cobertura m√≠nima de 80%
diff --git a/ai-tasks/task_interface.ts b/ai-tasks/task_interface.ts
new file mode 100644
index 0000000..3ef4db9
--- /dev/null
+++ b/ai-tasks/task_interface.ts
@@ -0,0 +1,46 @@
+/**
+ * Interface para defini√ß√£o de Tasks do Protocolo Supremo v4.0
+ */
+
+export interface Task {
+  id: string;
+  title: string;
+  description: string;
+  acceptance_criteria: string[];
+  files_to_create: string[];
+  files_to_modify: string[];
+  dependencies: string[];
+  estimated_effort: string;
+  status?: TaskStatus;
+  created_at?: Date;
+  updated_at?: Date;
+}
+
+export enum TaskStatus {
+  NOT_STARTED = 'not_started',
+  IN_PROGRESS = 'in_progress',
+  BLOCKED = 'blocked',
+  COMPLETED = 'completed',
+  FAILED = 'failed',
+}
+
+export interface TaskExecutionResult {
+  task_id: string;
+  success: boolean;
+  message: string;
+  errors?: string[];
+  logs?: string[];
+  execution_time_ms?: number;
+}
+
+export interface TaskManagerConfig {
+  tasks_directory: string;
+  log_level: 'info' | 'warn' | 'error' | 'debug';
+  enable_validation: boolean;
+}
+
+export interface TaskDay {
+  day: number;
+  protocol_version: string;
+  tasks: Task[];
+}
diff --git a/ai-tasks/task_manager.ts b/ai-tasks/task_manager.ts
new file mode 100644
index 0000000..e28d791
--- /dev/null
+++ b/ai-tasks/task_manager.ts
@@ -0,0 +1,251 @@
+/**
+ * TaskManager - Sistema de gerenciamento de tasks do Protocolo Supremo v4.0
+ */
+
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+import { Task, TaskDay, TaskExecutionResult, TaskManagerConfig, TaskStatus } from './task_interface';
+
+export class TaskManager {
+  private config: TaskManagerConfig;
+  private tasks: Map<string, Task> = new Map();
+
+  constructor(config: Partial<TaskManagerConfig> = {}) {
+    this.config = {
+      tasks_directory: config.tasks_directory || './ai-tasks',
+      log_level: config.log_level || 'info',
+      enable_validation: config.enable_validation ?? true,
+    };
+  }
+
+  /**
+   * Carrega tasks de um arquivo JSON
+   */
+  async loadTasksFromFile(filePath: string): Promise<Task[]> {
+    try {
+      const absolutePath = path.resolve(filePath);
+      
+      if (!fs.existsSync(absolutePath)) {
+        throw new Error(`Arquivo n√£o encontrado: ${absolutePath}`);
+      }
+
+      const fileContent = fs.readFileSync(absolutePath, 'utf-8');
+      const data = JSON.parse(fileContent) as TaskDay;
+
+      if (this.config.enable_validation) {
+        this.validateTaskDay(data);
+      }
+
+      // Armazena tasks no Map interno
+      data.tasks.forEach(task => {
+        task.status = task.status || TaskStatus.NOT_STARTED;
+        task.created_at = task.created_at || new Date();
+        this.tasks.set(task.id, task);
+      });
+
+      this.log('info', `‚úÖ Carregadas ${data.tasks.length} tasks do arquivo ${filePath}`);
+      return data.tasks;
+    } catch (error) {
+      this.log('error', `‚ùå Erro ao carregar tasks: ${error instanceof Error ? error.message : String(error)}`);
+      throw error;
+    }
+  }
+
+  /**
+   * Valida estrutura do TaskDay JSON
+   */
+  private validateTaskDay(data: TaskDay): void {
+    if (!data.day || typeof data.day !== 'number') {
+      throw new Error('Campo "day" inv√°lido ou ausente');
+    }
+
+    if (!data.protocol_version || typeof data.protocol_version !== 'string') {
+      throw new Error('Campo "protocol_version" inv√°lido ou ausente');
+    }
+
+    if (!Array.isArray(data.tasks)) {
+      throw new Error('Campo "tasks" deve ser um array');
+    }
+
+    data.tasks.forEach((task, index) => {
+      this.validateTask(task, index);
+    });
+  }
+
+  /**
+   * Valida estrutura de uma Task individual
+   */
+  private validateTask(task: Task, index: number): void {
+    const requiredFields = ['id', 'title', 'description', 'acceptance_criteria', 'files_to_create', 'files_to_modify', 'dependencies', 'estimated_effort'];
+    
+    requiredFields.forEach(field => {
+      if (!(field in task)) {
+        throw new Error(`Task[${index}]: campo obrigat√≥rio "${field}" ausente`);
+      }
+    });
+
+    if (!Array.isArray(task.acceptance_criteria)) {
+      throw new Error(`Task[${index}]: "acceptance_criteria" deve ser array`);
+    }
+
+    if (!Array.isArray(task.files_to_create)) {
+      throw new Error(`Task[${index}]: "files_to_create" deve ser array`);
+    }
+
+    if (!Array.isArray(task.files_to_modify)) {
+      throw new Error(`Task[${index}]: "files_to_modify" deve ser array`);
+    }
+
+    if (!Array.isArray(task.dependencies)) {
+      throw new Error(`Task[${index}]: "dependencies" deve ser array`);
+    }
+  }
+
+  /**
+   * Retorna task por ID
+   */
+  getTask(taskId: string): Task | undefined {
+    return this.tasks.get(taskId);
+  }
+
+  /**
+   * Lista todas as tasks carregadas
+   */
+  getAllTasks(): Task[] {
+    return Array.from(this.tasks.values());
+  }
+
+  /**
+   * Filtra tasks por status
+   */
+  getTasksByStatus(status: TaskStatus): Task[] {
+    return this.getAllTasks().filter(task => task.status === status);
+  }
+
+  /**
+   * Atualiza status de uma task
+   */
+  updateTaskStatus(taskId: string, status: TaskStatus): boolean {
+    const task = this.tasks.get(taskId);
+    if (!task) {
+      this.log('warn', `Task ${taskId} n√£o encontrada`);
+      return false;
+    }
+
+    task.status = status;
+    task.updated_at = new Date();
+    this.log('info', `Task ${taskId} status atualizado para ${status}`);
+    return true;
+  }
+
+  /**
+   * Executa handler de uma task (placeholder para extens√£o futura)
+   */
+  async executeTask(taskId: string): Promise<TaskExecutionResult> {
+    const startTime = Date.now();
+    const task = this.tasks.get(taskId);
+
+    if (!task) {
+      return {
+        task_id: taskId,
+        success: false,
+        message: `Task ${taskId} n√£o encontrada`,
+        errors: ['Task n√£o existe no gerenciador'],
+      };
+    }
+
+    this.log('info', `üöÄ Iniciando execu√ß√£o da task ${taskId}: ${task.title}`);
+    this.updateTaskStatus(taskId, TaskStatus.IN_PROGRESS);
+
+    try {
+      // Placeholder: integra√ß√£o futura com Orchestrator/actions
+      // Por enquanto apenas simula execu√ß√£o bem-sucedida
+      await this.simulateExecution(task);
+
+      this.updateTaskStatus(taskId, TaskStatus.COMPLETED);
+      const executionTime = Date.now() - startTime;
+
+      this.log('info', `‚úÖ Task ${taskId} executada com sucesso em ${executionTime}ms`);
+
+      return {
+        task_id: taskId,
+        success: true,
+        message: `Task ${task.title} executada com sucesso`,
+        execution_time_ms: executionTime,
+        logs: [`Crit√©rios de aceita√ß√£o: ${task.acceptance_criteria.length}`, `Arquivos a criar: ${task.files_to_create.length}`],
+      };
+    } catch (error) {
+      this.updateTaskStatus(taskId, TaskStatus.FAILED);
+      const executionTime = Date.now() - startTime;
+
+      this.log('error', `‚ùå Falha na execu√ß√£o da task ${taskId}: ${error instanceof Error ? error.message : String(error)}`);
+
+      return {
+        task_id: taskId,
+        success: false,
+        message: `Falha na execu√ß√£o: ${error instanceof Error ? error.message : String(error)}`,
+        errors: [error instanceof Error ? error.message : String(error)],
+        execution_time_ms: executionTime,
+      };
+    }
+  }
+
+  /**
+   * Simula execu√ß√£o (placeholder)
+   */
+  private async simulateExecution(task: Task): Promise<void> {
+    // Simula delay de processamento
+    await new Promise(resolve => setTimeout(resolve, 100));
+    
+    // Simula valida√ß√£o de depend√™ncias
+    if (task.dependencies.length > 0) {
+      this.log('debug', `Verificando depend√™ncias: ${task.dependencies.join(', ')}`);
+    }
+  }
+
+  /**
+   * Sistema de logging simples
+   */
+  private log(level: 'info' | 'warn' | 'error' | 'debug', message: string): void {
+    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
+    const configLevel = levels[this.config.log_level];
+    const messageLevel = levels[level];
+
+    if (messageLevel >= configLevel) {
+      const timestamp = new Date().toISOString();
+      const prefix = {
+        info: '‚ÑπÔ∏è',
+        warn: '‚ö†Ô∏è',
+        error: '‚ùå',
+        debug: 'üîç',
+      }[level];
+
+      console.log(`[${timestamp}] ${prefix} [TaskManager] ${message}`);
+    }
+  }
+
+  /**
+   * Gera relat√≥rio de status
+   */
+  getStatusReport(): Record<string, unknown> {
+    const tasks = this.getAllTasks();
+    const byStatus = {
+      not_started: this.getTasksByStatus(TaskStatus.NOT_STARTED).length,
+      in_progress: this.getTasksByStatus(TaskStatus.IN_PROGRESS).length,
+      completed: this.getTasksByStatus(TaskStatus.COMPLETED).length,
+      failed: this.getTasksByStatus(TaskStatus.FAILED).length,
+      blocked: this.getTasksByStatus(TaskStatus.BLOCKED).length,
+    };
+
+    return {
+      total_tasks: tasks.length,
+      by_status: byStatus,
+      tasks: tasks.map(t => ({
+        id: t.id,
+        title: t.title,
+        status: t.status,
+        estimated_effort: t.estimated_effort,
+      })),
+    };
+  }
+}
diff --git a/generate-tasks-day3.js b/generate-tasks-day3.js
new file mode 100644
index 0000000..d033904
--- /dev/null
+++ b/generate-tasks-day3.js
@@ -0,0 +1,117 @@
+import { GoogleGenerativeAI } from "@google/generative-ai";
+import fs from "fs";
+
+const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
+
+if (!GEMINI_API_KEY) {
+  console.error("‚ùå Erro: GEMINI_API_KEY n√£o configurada");
+  process.exit(1);
+}
+
+async function generateTasksDay3() {
+  const client = new GoogleGenerativeAI(GEMINI_API_KEY);
+  const model = client.getGenerativeModel({ model: "gemini-2.0-flash-exp" });
+
+  // Ler Documento Mestre para contexto
+  const masterDoc = fs.readFileSync("DOCUMENTO_MESTRE_SERVIO_AI.md", "utf-8");
+
+  const prompt = `Tu √©s o Gemini, planejador estrat√©gico do Protocolo Supremo v4.0 do Servio.AI.
+
+## CONTEXTO:
+
+O Protocolo Supremo v4.0 foi APROVADO pelo Gemini e est√° agora ATIVO em main.
+
+Documento Mestre v4.0 est√° ativo. Sistema pronto para Fase de Implementa√ß√£o.
+
+## TAREFA:
+
+Gera um JSON de **6 tasks** para o **Dia 3** que:
+
+1. **Implementem incrementalmente** o Protocolo Supremo v4.0
+2. **Sejam pequenas e audit√°veis** (m√°ximo 2-3 arquivos por task)
+3. **Sigam ordem l√≥gica** (depend√™ncias respeitadas)
+4. **Incluam testes** para cada feature
+5. **Tenham aceita√ß√£o clara** (DoD - Definition of Done)
+
+## FOCO DAS TASKS:
+
+Dia 3 deve focar em:
+
+- **Task 3.1**: Implementar sistema de tasks autom√°tico (ai-tasks/day-X/)
+- **Task 3.2**: Integrar Gemini CLI com GitHub Actions
+- **Task 3.3**: Criar protocolo de logging e auditoria
+- **Task 3.4**: Implementar valida√ß√£o de Documento Mestre (parser)
+- **Task 3.5**: Criar dashboard de status do Protocolo v4.0
+- **Task 3.6**: Testes E2E do ciclo completo (10 passos)
+
+## FORMATO DO JSON:
+
+\`\`\`json
+{
+  "day": 3,
+  "protocol_version": "4.0",
+  "tasks": [
+    {
+      "id": "3.1",
+      "title": "Task Title",
+      "description": "Full description",
+      "acceptance_criteria": ["‚úÖ Criteria 1", "‚úÖ Criteria 2"],
+      "files_to_create": ["file1.ts", "file2.test.ts"],
+      "files_to_modify": ["existing.ts"],
+      "dependencies": ["2.4"],
+      "estimated_effort": "4h",
+      "security_notes": "Se aplic√°vel"
+    }
+  ]
+}
+\`\`\`
+
+## IMPORTANTE:
+
+- JSON deve ser **v√°lido e parse√°vel**
+- Cada task deve ter **descri√ß√£o t√©cnica completa**
+- Aceitar crit√©rios devem ser **espec√≠ficos e mensur√°veis**
+- Esfor√ßo estimado deve ser **realista**
+- Documentar **todas as depend√™ncias**
+
+---
+
+**Responde com APENAS o JSON v√°lido, sem explica√ß√µes adicionais.**`;
+
+  try {
+    console.log("üîç Gerando tasks para Dia 3...\n");
+
+    const result = await model.generateContent(prompt);
+    const tasksJson = result.response.text();
+
+    // Tentar fazer parse e validar JSON
+    let tasks;
+    try {
+      tasks = JSON.parse(tasksJson);
+      console.log("‚úÖ JSON v√°lido gerado!\n");
+    } catch (error) {
+      console.error("‚ùå JSON inv√°lido gerado pelo Gemini:");
+      console.error(tasksJson);
+      process.exit(1);
+    }
+
+    // Salvar arquivo
+    fs.writeFileSync(
+      "tasks-day-3-generated.json",
+      JSON.stringify(tasks, null, 2),
+      "utf-8"
+    );
+
+    console.log("üìã Tasks Geradas para Dia 3:\n");
+    console.log("================================");
+    console.log(JSON.stringify(tasks, null, 2));
+    console.log("================================\n");
+
+    console.log(`‚úÖ ${tasks.tasks.length} tasks salvas em: tasks-day-3-generated.json`);
+  } catch (error) {
+    console.error("‚ùå Erro ao gerar tasks:", error.message);
+    process.exit(1);
+  }
+}
+
+generateTasksDay3();
diff --git a/tasks-day-3-generated.json b/tasks-day-3-generated.json
new file mode 100644
index 0000000..43de27b
--- /dev/null
+++ b/tasks-day-3-generated.json
@@ -0,0 +1,102 @@
+{
+  "day": 3,
+  "protocol_version": "4.0",
+  "tasks": [
+    {
+      "id": "3.1",
+      "title": "Implementar sistema de tasks autom√°tico (ai-tasks/day-X/)",
+      "description": "Cria√ß√£o de um sistema autom√°tico para leitura e execu√ß√£o de tasks definidas em arquivos JSON",
+      "acceptance_criteria": [
+        "Sistema l√™ e parseia arquivos JSON de tasks",
+        "Sistema valida o schema dos arquivos",
+        "Sistema executa as a√ß√µes descritas",
+        "Sistema lida com erros apropriadamente",
+        "Logging b√°sico das a√ß√µes executadas"
+      ],
+      "files_to_create": ["ai-tasks/task_manager.ts", "ai-tasks/task_interface.ts", "ai-tasks/task_manager.test.ts"],
+      "files_to_modify": [],
+      "dependencies": [],
+      "estimated_effort": "8h"
+    },
+    {
+      "id": "3.2",
+      "title": "Integrar Gemini CLI com GitHub Actions",
+      "description": "Configura√ß√£o de workflow no GitHub Actions para executar Gemini CLI em eventos de push/PR",
+      "acceptance_criteria": [
+        "Workflow do GitHub Actions configurado",
+        "CLI executada em eventos de push e pull request",
+        "Workflow gera relat√≥rios e logs",
+        "Workflow configur√°vel para diferentes ambientes",
+        "Status da execu√ß√£o vis√≠vel no GitHub"
+      ],
+      "files_to_create": [".github/workflows/gemini_cli.yml"],
+      "files_to_modify": [],
+      "dependencies": [],
+      "estimated_effort": "6h"
+    },
+    {
+      "id": "3.3",
+      "title": "Criar protocolo de logging e auditoria",
+      "description": "Sistema de logging centralizado para registrar todas as a√ß√µes do Protocolo Supremo v4.0",
+      "acceptance_criteria": [
+        "Sistema de logging centralizado implementado",
+        "Logs incluem timestamps e severidade",
+        "Sistema de auditoria gera relat√≥rios",
+        "Sistema gera alertas em eventos suspeitos",
+        "Logs armazenados com seguran√ßa"
+      ],
+      "files_to_create": ["utils/logger.ts", "utils/auditor.ts", "models/log_entry.ts", "utils/logger.test.ts"],
+      "files_to_modify": [],
+      "dependencies": [],
+      "estimated_effort": "8h"
+    },
+    {
+      "id": "3.4",
+      "title": "Implementar valida√ß√£o de Documento Mestre (parser)",
+      "description": "Parser para validar a estrutura e conte√∫do do Documento Mestre v4.0",
+      "acceptance_criteria": [
+        "Parser implementado para validar Documento Mestre v4.0",
+        "Parser verifica a estrutura do documento",
+        "Parser verifica campos obrigat√≥rios",
+        "Parser valida os valores dos campos",
+        "Testes unit√°rios cobrem cen√°rios de valida√ß√£o"
+      ],
+      "files_to_create": ["master_document/parser.ts", "master_document/schema.json", "master_document/parser.test.ts"],
+      "files_to_modify": [],
+      "dependencies": [],
+      "estimated_effort": "10h"
+    },
+    {
+      "id": "3.5",
+      "title": "Criar dashboard de status do Protocolo v4.0",
+      "description": "Dashboard para monitorar status do Protocolo Supremo v4.0 com m√©tricas em tempo real",
+      "acceptance_criteria": [
+        "Dashboard criado e funcional",
+        "Exibe vers√£o do protocolo e status das tasks",
+        "Exibe m√©tricas de erro e tempo de execu√ß√£o",
+        "Acess√≠vel via web com atualiza√ß√£o em tempo real",
+        "UI/UX intuitiva"
+      ],
+      "files_to_create": ["dashboard/index.html", "dashboard/app.js", "dashboard/style.css", "dashboard/api.ts"],
+      "files_to_modify": [],
+      "dependencies": [],
+      "estimated_effort": "12h"
+    },
+    {
+      "id": "3.6",
+      "title": "Testes E2E do ciclo completo (10 passos)",
+      "description": "Testes End-to-End para validar ciclo completo do Protocolo Supremo v4.0",
+      "acceptance_criteria": [
+        "Testes E2E implementados para ciclo completo",
+        "Testes cobrem os 10 passos do protocolo",
+        "Componentes funcionam corretamente em conjunto",
+        "Testes geram relat√≥rios detalhados",
+        "Cobertura de c√≥digo acima de 80%"
+      ],
+      "files_to_create": ["e2e/protocol_test.ts", "e2e/test_data.json"],
+      "files_to_modify": [],
+      "dependencies": ["3.1", "3.2", "3.3", "3.4", "3.5"],
+      "estimated_effort": "16h"
+    }
+  ]
+}
diff --git a/tests/task_manager.test.ts b/tests/task_manager.test.ts
new file mode 100644
index 0000000..6731078
--- /dev/null
+++ b/tests/task_manager.test.ts
@@ -0,0 +1,292 @@
+/**
+ * Testes unit√°rios para TaskManager
+ */
+
+import { describe, it, expect, beforeEach, vi } from 'vitest';
+import * as fs from 'node:fs';
+import { TaskManager } from '../ai-tasks/task_manager';
+import { TaskStatus } from '../ai-tasks/task_interface';
+
+// Mock do m√≥dulo fs
+vi.mock('fs');
+
+describe('TaskManager', () => {
+  let taskManager: TaskManager;
+
+  beforeEach(() => {
+    taskManager = new TaskManager({
+      log_level: 'error', // Silencia logs durante testes
+    });
+    vi.clearAllMocks();
+  });
+
+  describe('Inicializa√ß√£o', () => {
+    it('deve criar inst√¢ncia com configura√ß√£o padr√£o', () => {
+      const tm = new TaskManager();
+      expect(tm).toBeDefined();
+      expect(tm.getAllTasks()).toEqual([]);
+    });
+
+    it('deve aceitar configura√ß√£o customizada', () => {
+      const tm = new TaskManager({
+        tasks_directory: './custom-tasks',
+        log_level: 'debug',
+        enable_validation: false,
+      });
+      expect(tm).toBeDefined();
+    });
+  });
+
+  describe('loadTasksFromFile', () => {
+    it('deve carregar tasks v√°lidas de arquivo JSON', async () => {
+      const mockData = {
+        day: 3,
+        protocol_version: '4.0',
+        tasks: [
+          {
+            id: '3.1',
+            title: 'Task de teste',
+            description: 'Descri√ß√£o teste',
+            acceptance_criteria: ['Crit√©rio 1'],
+            files_to_create: ['file1.ts'],
+            files_to_modify: [],
+            dependencies: [],
+            estimated_effort: '2h',
+          },
+        ],
+      };
+
+      vi.mocked(fs.existsSync).mockReturnValue(true);
+      vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(mockData));
+
+      const tasks = await taskManager.loadTasksFromFile('test.json');
+
+      expect(tasks).toHaveLength(1);
+      expect(tasks[0].id).toBe('3.1');
+      expect(tasks[0].status).toBe(TaskStatus.NOT_STARTED);
+    });
+
+    it('deve lan√ßar erro se arquivo n√£o existir', async () => {
+      vi.mocked(fs.existsSync).mockReturnValue(false);
+
+      await expect(taskManager.loadTasksFromFile('missing.json')).rejects.toThrow(
+        /Arquivo n√£o encontrado/
+      );
+    });
+
+    it('deve lan√ßar erro para JSON inv√°lido', async () => {
+      vi.mocked(fs.existsSync).mockReturnValue(true);
+      vi.mocked(fs.readFileSync).mockReturnValue('{ invalid json }');
+
+      await expect(taskManager.loadTasksFromFile('invalid.json')).rejects.toThrow();
+    });
+
+    it('deve validar estrutura do TaskDay', async () => {
+      const invalidData = {
+        day: 3,
+        // Falta protocol_version
+        tasks: [],
+      };
+
+      vi.mocked(fs.existsSync).mockReturnValue(true);
+      vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(invalidData));
+
+      await expect(taskManager.loadTasksFromFile('test.json')).rejects.toThrow(
+        /protocol_version/
+      );
+    });
+
+    it('deve validar campos obrigat√≥rios de Task', async () => {
+      const invalidData = {
+        day: 3,
+        protocol_version: '4.0',
+        tasks: [
+          {
+            id: '3.1',
+            // Faltam campos obrigat√≥rios
+          },
+        ],
+      };
+
+      vi.mocked(fs.existsSync).mockReturnValue(true);
+      vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(invalidData));
+
+      await expect(taskManager.loadTasksFromFile('test.json')).rejects.toThrow(
+        /campo obrigat√≥rio/
+      );
+    });
+  });
+
+  describe('Gerenciamento de Tasks', () => {
+    beforeEach(async () => {
+      const mockData = {
+        day: 3,
+        protocol_version: '4.0',
+        tasks: [
+          {
+            id: '3.1',
+            title: 'Task 1',
+            description: 'Desc 1',
+            acceptance_criteria: ['C1'],
+            files_to_create: [],
+            files_to_modify: [],
+            dependencies: [],
+            estimated_effort: '2h',
+          },
+          {
+            id: '3.2',
+            title: 'Task 2',
+            description: 'Desc 2',
+            acceptance_criteria: ['C2'],
+            files_to_create: [],
+            files_to_modify: [],
+            dependencies: ['3.1'],
+            estimated_effort: '4h',
+          },
+        ],
+      };
+
+      vi.mocked(fs.existsSync).mockReturnValue(true);
+      vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(mockData));
+
+      await taskManager.loadTasksFromFile('test.json');
+    });
+
+    it('deve retornar task por ID', () => {
+      const task = taskManager.getTask('3.1');
+      expect(task).toBeDefined();
+      expect(task?.title).toBe('Task 1');
+    });
+
+    it('deve retornar undefined para task inexistente', () => {
+      const task = taskManager.getTask('999');
+      expect(task).toBeUndefined();
+    });
+
+    it('deve listar todas as tasks', () => {
+      const tasks = taskManager.getAllTasks();
+      expect(tasks).toHaveLength(2);
+    });
+
+    it('deve filtrar tasks por status', () => {
+      const notStarted = taskManager.getTasksByStatus(TaskStatus.NOT_STARTED);
+      expect(notStarted).toHaveLength(2);
+
+      const completed = taskManager.getTasksByStatus(TaskStatus.COMPLETED);
+      expect(completed).toHaveLength(0);
+    });
+
+    it('deve atualizar status de task', () => {
+      const result = taskManager.updateTaskStatus('3.1', TaskStatus.IN_PROGRESS);
+      expect(result).toBe(true);
+
+      const task = taskManager.getTask('3.1');
+      expect(task?.status).toBe(TaskStatus.IN_PROGRESS);
+      expect(task?.updated_at).toBeDefined();
+    });
+
+    it('deve retornar false ao atualizar task inexistente', () => {
+      const result = taskManager.updateTaskStatus('999', TaskStatus.COMPLETED);
+      expect(result).toBe(false);
+    });
+  });
+
+  describe('executeTask', () => {
+    beforeEach(async () => {
+      const mockData = {
+        day: 3,
+        protocol_version: '4.0',
+        tasks: [
+          {
+            id: '3.1',
+            title: 'Task execut√°vel',
+            description: 'Desc',
+            acceptance_criteria: ['C1', 'C2'],
+            files_to_create: ['file1.ts', 'file2.ts'],
+            files_to_modify: [],
+            dependencies: [],
+            estimated_effort: '2h',
+          },
+        ],
+      };
+
+      vi.mocked(fs.existsSync).mockReturnValue(true);
+      vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(mockData));
+
+      await taskManager.loadTasksFromFile('test.json');
+    });
+
+    it('deve executar task com sucesso', async () => {
+      const result = await taskManager.executeTask('3.1');
+
+      expect(result.success).toBe(true);
+      expect(result.task_id).toBe('3.1');
+      expect(result.execution_time_ms).toBeGreaterThan(0);
+      expect(result.logs).toBeDefined();
+
+      const task = taskManager.getTask('3.1');
+      expect(task?.status).toBe(TaskStatus.COMPLETED);
+    });
+
+    it('deve retornar erro para task inexistente', async () => {
+      const result = await taskManager.executeTask('999');
+
+      expect(result.success).toBe(false);
+      expect(result.errors).toBeDefined();
+      expect(result.errors?.[0]).toContain('n√£o existe');
+    });
+  });
+
+  describe('getStatusReport', () => {
+    beforeEach(async () => {
+      const mockData = {
+        day: 3,
+        protocol_version: '4.0',
+        tasks: [
+          {
+            id: '3.1',
+            title: 'Task 1',
+            description: 'Desc',
+            acceptance_criteria: [],
+            files_to_create: [],
+            files_to_modify: [],
+            dependencies: [],
+            estimated_effort: '2h',
+          },
+          {
+            id: '3.2',
+            title: 'Task 2',
+            description: 'Desc',
+            acceptance_criteria: [],
+            files_to_create: [],
+            files_to_modify: [],
+            dependencies: [],
+            estimated_effort: '4h',
+          },
+        ],
+      };
+
+      vi.mocked(fs.existsSync).mockReturnValue(true);
+      vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(mockData));
+
+      await taskManager.loadTasksFromFile('test.json');
+    });
+
+    it('deve gerar relat√≥rio de status', () => {
+      const report = taskManager.getStatusReport();
+
+      expect(report.total_tasks).toBe(2);
+      expect(report.by_status).toBeDefined();
+      expect((report.by_status as Record<string, number>).not_started).toBe(2);
+      expect(report.tasks).toHaveLength(2);
+    });
+
+    it('deve refletir mudan√ßas de status no relat√≥rio', () => {
+      taskManager.updateTaskStatus('3.1', TaskStatus.COMPLETED);
+
+      const report = taskManager.getStatusReport();
+      expect((report.by_status as Record<string, number>).completed).toBe(1);
+      expect((report.by_status as Record<string, number>).not_started).toBe(1);
+    });
+  });
+});
